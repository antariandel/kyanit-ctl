<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>Kyanit CTL Documentation</title>
<meta name="description" content="Kyanit CTL …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>
/* Hide "Module kyanitctl" title */
h1.title {
display: none;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kyanitctl</code></h1>
</header>
<section id="section-intro">
<h1 id="kyanit-ctl">Kyanit CTL</h1>
<p>Kyanit CTL is a command-line utility for interfacing and interacting with Kyanit.</p>
<p>For a Python API, see Kyanit API at <a href="https://kyanit.eu/docs/kyanit-api.">https://kyanit.eu/docs/kyanit-api.</a></p>
<p>Install the latest released version of Kyanit CTL from PyPI with:</p>
<pre><code>pip install kyanitctl
</code></pre>
<p>After installation, Kyanit CTL will be available through the <a title="kyanitctl" href="#kyanitctl"><code>kyanitctl</code></a> command.</p>
<h1 id="usage">Usage</h1>
<p>Refer to the command-line help with <code>kyanitctl -h</code>.</p>
<h1 id="license-notice">License Notice</h1>
<p>Copyright (C) 2020 Zsolt Nagy</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the
GNU General Public License as published by the Free Software Foundation, version 3 of the License.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.
If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Kyanit CTL
# Copyright (C) 2020 Zsolt Nagy
#
# This program is free software: you can redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program.
# If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;
# Kyanit CTL

Kyanit CTL is a command-line utility for interfacing and interacting with Kyanit.

For a Python API, see Kyanit API at https://kyanit.eu/docs/kyanit-api.

Install the latest released version of Kyanit CTL from PyPI with:

```
pip install kyanitctl
```

After installation, Kyanit CTL will be available through the `kyanitctl` command.

# Usage

Refer to the command-line help with `kyanitctl -h`.

# License Notice

Copyright (C) 2020 Zsolt Nagy

This program is free software: you can redistribute it and/or modify it under the terms of the
GNU General Public License as published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.
If not, see &lt;https://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;


import os
import time
import json
import pathlib
import argparse
import collections

from kyanitapi import Kyanit, KyanitConnectionError, KyanitRequestError
from kyanitapi import ip_is_valid, netmask_is_valid, get_networks

try:
    from ._version import __version__  # noqa
except ImportError:
    pass


__pdoc__ = {}

KYANITCTL_USER_DIR = os.path.join(pathlib.Path.home(), &#39;.kyanitctl&#39;)

if not os.path.exists(KYANITCTL_USER_DIR):
    os.mkdir(KYANITCTL_USER_DIR)

EXAMPLE_CODE = &#39;&#39;&#39;
# This code is imported on startup, then main is called, if it exists. Neither main, nor cleanup
# should block for too long. Use coroutines through kyanit.runner.create_task(&#39;name&#39;, coro) for
# continuous or longer tasks. Any errors (including from coroutines) will be passed to cleanup.
# The @kyanit.controls() decorator adds functionality to the LEDs and button. It can be removed if
# this is not required, to save approximately 1k of RAM.

# To get started, head to https://kyanit.eu

import kyanit

@kyanit.controls()
def main():
    pass


@kyanit.controls()
def cleanup(exception):
    pass
&#39;&#39;&#39;


def input_validate(msg, validator):
    inp = &#39;&#39;
    while not validator(inp):
        print(&#39;{}: &#39;.format(msg), end=&#39;&#39;)
        inp = input()
        if not validator(inp):
            print(&#39;Invalid, try again...&#39;)
    return inp


__pdoc__[&#39;input_validate&#39;] = False


def get_saved_network():
    try:
        network = json.load(open(os.path.join(KYANITCTL_USER_DIR, &#39;network.json&#39;)))
        return (network[&#39;interface&#39;], network[&#39;ip_address&#39;])
    except (FileNotFoundError, KeyError):
        return None


__pdoc__[&#39;get_saved_network&#39;] = False


def save_network(network):
    try:
        if len(network) != 2:
            raise TypeError(&#39;network must be indexable with 2 items&#39;)
    except TypeError:
        raise TypeError(&#39;network must be indexable with 2 items&#39;)
    json.dump({
        &#39;interface&#39;: network[0],
        &#39;ip_address&#39;: network[1]
    }, open(os.path.join(KYANITCTL_USER_DIR, &#39;network.json&#39;), &#39;w&#39;))


__pdoc__[&#39;save_network&#39;] = False


def _action_handler(extra_msg=&#39;&#39;):
    def decorated(func):
        def handle_action(*args, **kwargs):
            try:
                func(*args, **kwargs)
            except (KyanitConnectionError, OSError):
                print(&#39;\nERROR: Cannot connect to Kyanit.&#39;, end=&#39;\n\n&#39;)
                if extra_msg:
                    print(extra_msg)
                exit()
            except KyanitRequestError as exc:
                print(&#39;\nERROR: Kyanit responded with status code {}&#39;.format(exc.args[0]),
                      end=&#39;\n\n&#39;)
        return handle_action
    return decorated


class VerboseAction:
    def __init__(self, kyanit: Kyanit):
        if not isinstance(kyanit, Kyanit):
            raise ValueError(&#39;must provide instance of Kyanit&#39;)
        self.kyanit: Kyanit = kyanit
    
    @_action_handler(&#39;MAKE SURE YOU\&#39;RE CONNECTED TO KYANIT\&#39;S WLAN!&#39;)
    def setup(self, static=False):
        print(&#39;=== Kyanit WLAN Setup Procedure ===&#39;, end=&#39;\n\n&#39;)
        status = self.kyanit.get_status()
        print(&#39;Connection established. Firmware version is {}.&#39;
              .format(status[&#39;firmware_version&#39;]))
        print(&#39;Network name (SSID): &#39;, end=&#39;&#39;)
        ssid = input()
        print(&#39;Password (blank if Open): &#39;, end=&#39;&#39;)
        password = input()
        if not static:
            ifconfig = &#39;dhcp&#39;
        else:
            ip_addr = input_validate(&#39;IP Address&#39;, ip_is_valid)
            netmask = input_validate(&#39;Netmask&#39;, netmask_is_valid)
            gateway = input_validate(&#39;Gateway&#39;, ip_is_valid)
            dns = input_validate(&#39;DNS&#39;, ip_is_valid)
            ifconfig = (ip_addr, netmask, gateway, dns)
        config = {
            &#39;ssid&#39;: ssid,
            &#39;password&#39;: password,
            &#39;ifconfig&#39;: ifconfig
        }
        print(&#39;\nConfiguration (wlan.json) will be:&#39;, end=&#39;\n\n&#39;)
        print(json.dumps(config, indent=2, sort_keys=True), end=&#39;\n\n&#39;)
        print(&#39;Ready to upload to Kyanit? (YES/no) &#39;, end=&#39;&#39;)
        try:
            upload = input()
            upload = True if not upload or upload.upper() == &#39;YES&#39; else False
            if not upload:
                print(&#39;Aborted.&#39;, end=&#39;\n\n&#39;)
                return
            print(&#39;\nUploading...&#39;)
            self.kyanit.put_file(&#39;wlan.json&#39;, json.dumps(config))
            print(&#39;Uploading blank code.py (if non-existent)...&#39;)
            if &#39;code.py&#39; not in self.kyanit.get_file_list():
                self.kyanit.put_file(&#39;code.py&#39;, EXAMPLE_CODE)
            print(&#39;Rebooting...&#39;)
            self.kyanit.reboot()
            print(&#39;Done.&#39;, end=&#39;\n\n&#39;)
        except KeyboardInterrupt:
            print(&#39;Aborted.&#39;, end=&#39;\n\n&#39;)
    
    @_action_handler(&#39;CHECK THE COLOR ID OR THE IP ADDRESS AGAIN!&#39;)
    def ping(self):
        print(&#39;Pinging...&#39;)
        success = self.kyanit.ping(verbose=True)
        print()
        if success:
            print(&#39;Retrieving system status...&#39;, end=&#39;\r&#39;)
            self.kyanit.get_status()
            print(&#39;Retrieving system status done.&#39;)
            conn_info = self.kyanit.info()
            print(&#39;Kyanit {} is responding on IP address {}.&#39;
                  .format(conn_info[&#39;color_id&#39;], conn_info[&#39;ip_addr&#39;]))
        else:
            raise KyanitConnectionError
        print()

    @_action_handler()
    def print_status_info(self, tries=1):
        print(&#39;Retrieving system status...&#39;)
        status = collections.OrderedDict(sorted(self.kyanit.get_status(tries).items()))
        print()
        for key in status:
            if key != &#39;error_traceback&#39; and key != &#39;color_id&#39;:
                print(&#39;{:&gt;20}: {}&#39;.format(key.replace(&#39;_&#39;, &#39; &#39;).capitalize(), status[key]))
            elif key == &#39;error_traceback&#39;:
                if status[&#39;error_traceback&#39;]:
                    print(&#39;{:&gt;20}: {}&#39;.format(&#39;Error detail&#39;,
                                              &#39;Traceback (most recent call last):&#39;))
                    for line in status[&#39;error_traceback&#39;]:
                        print(&#39;{:&gt;20}  {}&#39;.format(&#39;&#39;, line))
        print()
    
    @_action_handler()
    def stop(self, force=False):
        print(&#39;Stopping code.py{}...&#39;.format(&#39; (forcibly)&#39; if force else &#39;&#39;), end=&#39;\r&#39;)
        self.kyanit.stop(force)
        print(&#39;Stopping code.py{} done.&#39;.format(&#39; (forcibly)&#39; if force else &#39;&#39;))
    
    @_action_handler()
    def start(self):
        print(&#39;Starting code.py...&#39;, end=&#39;\r&#39;)
        self.kyanit.start()
        print(&#39;Starting code.py done.&#39;)
    
    @_action_handler()
    def reboot(self, tries=5):
        print(&#39;Rebooting (hard reset) ...&#39;, end=&#39;\r&#39;)
        self.kyanit.reboot()
        # wait until reboot is asserted
        time.sleep(1.5)
        # wait until Kyanit comes back
        self.kyanit.get_status(tries)
        print(&#39;Rebooting (hard reset) done.&#39;)
        print()

    # @_action_handler()
    # def reset(self, tries=5):
    #     print(&#39;Rebooting (soft reset) ...&#39;, end=&#39;\r&#39;)
    #     self.kyanit.reset()
    #     # wait until reboot is asserted
    #     time.sleep(1.5)
    #     # wait until Kyanit comes back
    #     self.kyanit.get_status(tries)
    #     print(&#39;Rebooting (soft reset) done.&#39;)
    #     print()
    
    @_action_handler()
    def print_file_list(self):
        print(&#39;Retrieving file list...&#39;, end=&#39;\r&#39;)
        files = self.kyanit.get_file_list()
        print(&#39;Retrieving file list done.&#39;)
        print(&#39;Files on Kyanit:&#39;, end=&#39;\n\n&#39;)
        for file in files:
            print(file)
        print()
    
    @_action_handler()
    def get_files(self, filenames=[], all_files=False):
        if all_files:
            print(&#39;Downloading all files...&#39;)
            for filename in self.kyanit.get_file_list():
                print(&#39;Downloading \&#39;{}\&#39; ...&#39;.format(filename), end=&#39;\r&#39;)
                with open(filename, &#39;wb&#39;) as file:
                    file.write(self.kyanit.get_file(filename))
                    print(&#39;Downloading \&#39;{}\&#39; done.&#39;.format(filename))
            print(&#39;Done.&#39;, end=&#39;\n\n&#39;)
            return
        
        for filename in filenames:
            try:
                print(&#39;Downloading \&#39;{}\&#39; ...&#39;.format(filename), end=&#39;\r&#39;)
                data = self.kyanit.get_file(filename)
                with open(filename, &#39;wb&#39;) as file:
                    file.write(data)
                print(&#39;Downloading \&#39;{}\&#39; done.&#39;.format(filename))
            except KyanitRequestError as exc:
                if exc.args[0] == 404:
                    print(&#39;Downloading \&#39;{}\&#39; (not found, skipping)&#39;.format(filename))
                else:
                    print(&#39;Downloading \&#39;{}\&#39; (error {})&#39;.format(filename, exc.args[0]))
        print(&#39;Done.&#39;, end=&#39;\n\n&#39;)
    
    @_action_handler()
    def print_file(self, filename):
        try:
            print(&#39;Downloading \&#39;{}\&#39; ...&#39;.format(filename), end=&#39;\r&#39;)
            data = self.kyanit.get_file(filename)
            print(&#39;Downloading \&#39;{}\&#39; done.&#39;.format(filename))
            print(&#39;Contents:&#39;, end=&#39;\n\n&#39;)
            try:
                print(data.decode())
            except Exception:
                print(data)
        except KyanitRequestError as exc:
            if exc.args[0] == 404:
                print()
                print(&#39;File \&#39;{}\&#39; not found on Kyanit.&#39;.format(filename))
            else:
                raise
    
    @_action_handler()
    def put_files(self, pathnames):
        for path in pathnames:
            if os.path.isdir(path):
                for name in os.listdir(path):
                    if not os.path.isdir(os.path.join(path, name)):
                        print(&#39;Uploading \&#39;{}\&#39; ...&#39;.format(os.path.join(path, name)), end=&#39;\r&#39;)
                        with open(os.path.join(path, name), &#39;rb&#39;) as file:
                            self.kyanit.put_file(os.path.basename(name), file)
                        print(&#39;Uploading \&#39;{}\&#39; done.&#39;.format(os.path.join(path, name)))
            else:
                print(&#39;Uploading \&#39;{}\&#39; ...&#39;.format(path), end=&#39;\r&#39;)
                if not os.path.exists(path):
                    print(&#39;Uploading \&#39;{}\&#39; (not found, skipping)&#39;.format(path))
                    continue
                with open(os.path.basename(path), &#39;rb&#39;) as file:
                    self.kyanit.put_file(os.path.basename(path), file)
                print(&#39;Uploading \&#39;{}\&#39; done.&#39;.format(path))
        print(&#39;Done.&#39;, end=&#39;\n\n&#39;)
    
    @_action_handler()
    def delete_files(self, filenames=[], purge=False):
        if purge:
            print(&#39;Deleting all files on Kyanit (except wlan.json)!&#39;)
            file_list = self.kyanit.get_file_list()
            for filename in file_list:
                if filename != &#39;wlan.json&#39;:
                    print(&#39;Deleting \&#39;{}\&#39; ...&#39;.format(filename), end=&#39;\r&#39;)
                    self.kyanit.delete_file(filename)
                    print(&#39;Deleting \&#39;{}\&#39; done.&#39;.format(filename))
            print(&#39;Done.&#39;, end=&#39;\n\n&#39;)
            return
        for filename in filenames:
            try:
                print(&#39;Deleting \&#39;{}\&#39; ...&#39;.format(filename), end=&#39;\r&#39;)
                self.kyanit.delete_file(filename)
                print(&#39;Deleting \&#39;{}\&#39; done.&#39;.format(filename))
            except KyanitRequestError as exc:
                if exc.args[0] == 404:
                    print(&#39;Deleting \&#39;{}\&#39; (not found, skipping)&#39;.format(filename))
                else:
                    raise
        print(&#39;Done.&#39;, end=&#39;\n\n&#39;)
    
    @_action_handler()
    def rename_file(self, filename, newname):
        try:
            print(&#39;Renaming \&#39;{}\&#39; to \&#39;{}\&#39; ...&#39;.format(filename, newname), end=&#39;\r&#39;)
            self.kyanit.rename_file(filename, newname)
            print(&#39;Renaming \&#39;{}\&#39; to \&#39;{}\&#39; done.&#39;.format(filename, newname))
        except KyanitRequestError as exc:
            if exc.args[0] == 404:
                print(&#39;File \&#39;{}\&#39; not found on Kyanit.&#39;.format(filename))
            else:
                raise
        print()
    
    @_action_handler()
    def netvar(self, json_str=None):
        if json_str is None:
            print(&#39;Getting outbound netvar...&#39;, end=&#39;\r&#39;)
            netvar = self.kyanit.netvar()
            print(&#39;Getting outbound netvar done.&#39;)
            if netvar is None:
                print(&#39;Netvar empty.&#39;)
            else:
                print(&#39;Netvar is:&#39;, self.kyanit.netvar())
            print()
            return
        
        try:
            obj = json.loads(json_str)
        except json.decoder.JSONDecodeError:
            print(&#39;ERROR: Malformed JSON.&#39;)
        else:
            print(&#39;Setting inbound netvar...&#39;, end=&#39;\r&#39;)
            self.kyanit.netvar(obj)
            print(&#39;Setting inbound netvar done.&#39;)


__pdoc__[&#39;VerboseAction&#39;] = False


def main(*cli_args):
    parser = argparse.ArgumentParser(
        prog=&#39;kyanitctl&#39;,
        description=&#39;Console application for managing a Kyanit board. If more than one option is &#39;
                    &#39;provided, they are executed in the order they appear in the help.&#39;,
        usage=&#39;%(prog)s [-setup] [ColorID] [-ip IP] [options...]&#39;)
    parser.add_argument(&#39;colorid&#39;, nargs=&#39;?&#39;,
                        help=&#39;primary connection method; color identifier of the Kyanit, &#39;
                             &#39;which is a set of 3 letters representing colors Red, Green, Blue, &#39;
                             &#39;Cyan, Magenta, Yellow or White; after initial setup, these colors &#39;
                             &#39;show up on the Kyanit, when the button is pressed; example: RGB, BGY &#39;
                             &#39; etc.; must be omitted if -ip is given&#39;)
    parser.add_argument(&#39;-setup&#39;, action=&#39;store_true&#39;,
                        help=&#39;initial setup of Kyanit; perform when first connected to the &#39;
                             &#39;Kyanit\&#39;s WLAN; must be on Kyanit\&#39;s WLAN for setup to work; &#39;
                             &#39;no other actions will be performed; Color ID and -ip don\&#39;t have to &#39;
                             &#39;be provided, and are disregarded&#39;)
    parser.add_argument(&#39;-setupstatic&#39;, action=&#39;store_true&#39;,
                        help=&#39;same as setup, but this will configure the Kyanit with a static IP &#39;
                             &#39;instead of DHCP; only recommended if you know what you\&#39;re doing; &#39;
                             &#39;misconfigured static IP will render your Kyanit inaccessible, and a &#39;
                             &#39;rescue will be required&#39;)
    parser.add_argument(&#39;-ip&#39;, nargs=&#39;?&#39;,
                        help=&#39;alternative connection method; IP address of the Kyanit, &#39;
                             &#39;must be given if Color ID is omitted, or if Kyanit is on a non-/24 &#39;
                             &#39;network&#39;)
    parser.add_argument(&#39;-reset_network&#39;, action=&#39;store_true&#39;,
                        help=&#39;perform initial network selection again&#39;)
    parser.add_argument(&#39;-ping&#39;, action=&#39;store_true&#39;,
                        help=&#39;ping the Kyanit and get system state&#39;)
    parser.add_argument(&#39;-timeout&#39;, metavar=&#39;SECONDS&#39;, type=int,
                        help=&#39;set timeout for network operations, except ping; default is 5 &#39;
                             &#39;seconds&#39;)
    parser.add_argument(&#39;-files&#39;, action=&#39;store_true&#39;, help=&#39;list files currently on Kyanit&#39;)
    parser.add_argument(&#39;-get&#39;, action=&#39;extend&#39;, nargs=&#39;+&#39;, metavar=&#39;FILE&#39;,
                        help=&#39;a list of files to get from the Kyanit; warning, all existing local &#39;
                             &#39;files will be irreversibly OVERWRITTEN!&#39;)
    parser.add_argument(&#39;-getall&#39;, action=&#39;store_true&#39;, help=&#39;same as -get, but it gets all files&#39;)
    parser.add_argument(&#39;-cont&#39;, metavar=&#39;FILE&#39;,
                        help=&#39;print contents of a file on Kyanit&#39;)
    parser.add_argument(&#39;-delete&#39;, action=&#39;extend&#39;, nargs=&#39;+&#39;, metavar=&#39;FILE&#39;,
                        help=&#39;a list of files to delete on the Kyanit; WARNING: deleting wlan.json&#39;
                             &#39; will require performing the initial setup again&#39;)
    parser.add_argument(&#39;-purge&#39;, action=&#39;store_true&#39;,
                        help=&#39;same as -delete, but deletes all files; wlan.json is preserved&#39;)
    parser.add_argument(&#39;-put&#39;, action=&#39;extend&#39;, nargs=&#39;+&#39;, metavar=&#39;FILE&#39;,
                        help=&#39;a list of files and directories to upload on the Kyanit; only &#39;
                             &#39;top-level files will be uploaded from directories; existing remote &#39;
                             &#39;files will be irreversibly OVERWRITTEN!&#39;)
    parser.add_argument(&#39;-rename&#39;, action=&#39;extend&#39;, nargs=2, metavar=(&#39;OLD&#39;, &#39;NEW&#39;),
                        help=&#39;renames a file on Kyanit&#39;)
    parser.add_argument(&#39;-netvar&#39;, nargs=&#39;?&#39;, action=&#39;append&#39;, metavar=&#39;JSON&#39;,
                        help=&#39;get the outbound netvar if JSON is not specified,  or set the &#39;
                             &#39;inbound netvar to JSON; valid JSON must be specified, escape &#39;
                             &#39;quotes with \\\&#34; &#39;)
    parser.add_argument(&#39;-stop&#39;, action=&#39;store_true&#39;, help=&#39;start code.py&#39;)
    parser.add_argument(&#39;-stopforce&#39;, action=&#39;store_true&#39;,
                        help=&#39;forcibly stop code.py (no cleanup)&#39;)
    parser.add_argument(&#39;-start&#39;, action=&#39;store_true&#39;, help=&#39;stop running code.py&#39;)
    parser.add_argument(&#39;-reboot&#39;, action=&#39;store_true&#39;, help=&#39;reboot Kyanit (hard reset)&#39;)
    # parser.add_argument(&#39;-reset&#39;, action=&#39;store_true&#39;, help=&#39;reset Kyanit (soft reset)&#39;)
    parser.add_argument(&#39;-status&#39;, action=&#39;store_true&#39;, help=&#39;get status info&#39;)
    
    args = parser.parse_args(*cli_args)
    print()

    # SETUP

    if args.setup or args.setupstatic:
        kyanit = Kyanit(ip_addr=&#39;192.168.4.1&#39;)
        action = VerboseAction(kyanit)
        action.setup(static=args.setupstatic)
        exit()
    
    # BBB COLORID

    if args.colorid == &#39;BBB&#39;:
        print(&#39;A Color ID of BBB means the Kyanit lost connection to WiFi.&#39;)
        print(&#39;This may have happened, because your WiFi SSID or password has changed. &#39;
              &#39;In that case, power-cycle your Kyanit, connect to it, and re-run &#39;
              &#39;kyanitctl -setup.&#39;)
        print()
        exit()
    
    # SELECT NETWORK

    network = get_saved_network()
    if (network is None and args.colorid is not None) or args.reset_network:
        def select(networks):
            for network in enumerate(networks):
                print(&#39;{}:&#39;.format(network[0]), &#39;{:&lt;15}&#39;.format(network[1][1]), network[1][0])
            print()
            while True:
                print(&#39;Select network {}: &#39;.format(list(range(len(network)))), end=&#39;&#39;)
                index = input()
                try:
                    return networks[int(index)]
                except (IndexError, TypeError, ValueError):
                    print(&#39;Invalid selection.&#39;)
        print(&#39;=== Network Setup ===&#39;, end=&#39;\n\n&#39;)
        print(&#39;Connecting to Kyanit with the Color ID works on networks with a netmask of &#39;
              &#39;255.255.255.0 (most home wireless networks).&#39;)
        networks = get_networks()
        if len(networks) == 0:
            if not args.ip:
                print(&#39;No such network detected. Connection with Color ID is not supported. &#39;
                      &#39;Specify -ip instead. See kyanit -h for details.&#39;)
                exit()
        if len(networks) == 1:
            network = networks.pop()
            print(&#39;Detecting one such network \&#39;{}\&#39; with IP {}.&#39;
                  .format(network[0], network[1]))
            print(&#39;If Kyanit is not on this network, connect with -ip instead of the Color ID.&#39;)
        if len(networks) &gt; 1:
            print(&#39;Multiple such networks detected. Select the one Kyanit is connected to:&#39;)
            network = select(networks)
        if network is not None:
            save_network(network)
            print(&#39;Saved. You may re-run this setup with -reset_network.&#39;, end=&#39;\n\n&#39;)
        if args.reset_network:
            exit()

    # OPEN KYANIT

    try:
        kyanit = Kyanit(args.colorid, network[1] if network is not None else None, args.ip)
        kyanit.set_timeout(5)
    except ValueError as exc:
        if str(exc) == &#39;IP invalid&#39;:
            parser.print_usage()
            print()
            print(&#39;The IP address \&#39;{}\&#39; is invalid.&#39;.format(args.ip))
            print(&#39;See kyanitctl -h for help.&#39;, end=&#39;\n\n&#39;)
            exit()
        elif str(exc) == &#39;Color ID invalid&#39;:
            parser.print_usage()
            print()
            print(&#39;The Color ID \&#39;{}\&#39; is invalid. It either contains unsupported characters, or &#39;
                  &#39;the resulting IP address octet would be greater than 254.&#39;.format(args.colorid))
            print(&#39;See kyanitctl -h for help.&#39;, end=&#39;\n\n&#39;)
            exit()
        elif str(exc) == &#39;Network invalid&#39;:
            # kyanitapi error when invalid network address is passed to Kyanit()
            # this should not normally happen with kyanitctl, as network addresses are detected
            # automatically.
            print(&#39;ERROR: Unexpected error (network address invalid).&#39;)
            print(&#39;Try re-running kyanitctl -reset_network.&#39;, end=&#39;\n\n&#39;)
            exit()
        elif str(exc) == &#39;no connection method&#39;:
            parser.print_usage()
            print()
            print(&#39;No connection method. Either Color ID or -ip must be provided.&#39;)
            print(&#39;See kyanitctl -h for help.&#39;, end=&#39;\n\n&#39;)
            exit()
        elif str(exc) == &#39;bad connection method&#39;:
            parser.print_usage()
            print()
            print(&#39;Bad connection method. Either Color ID or -ip must be provided, &#39;
                  &#39;but not both.&#39;, end=&#39;\n\n&#39;)
            print(&#39;See kyanitctl -h for help.&#39;, end=&#39;\n\n&#39;)
            exit()
        else:
            raise exc
    
    if args.timeout:
        kyanit.set_timeout(args.timeout)

    if args.ip is None:
        print(&#39;=== Kyanit {} ({} through \&#39;{}\&#39;) ===&#39;
              .format(kyanit.info()[&#39;color_id&#39;], kyanit.info()[&#39;ip_addr&#39;], network[0]))
    else:
        print(&#39;=== Kyanit on {} ===&#39;.format(kyanit.info()[&#39;ip_addr&#39;]))
    print()

    action = VerboseAction(kyanit)

    # ACTIONS

    if args.ping:
        action.ping()
    
    if args.files:
        action.print_file_list()
    
    if args.get or args.getall:
        if args.getall:
            action.get_files(all_files=True)
        else:
            action.get_files(args.get)
    
    if args.cont:
        action.print_file(args.cont)

    if args.delete or args.purge:
        if args.purge:
            action.delete_files(purge=True)
        else:
            action.delete_files(args.delete)

    if args.put:
        action.put_files(args.put)
    
    if args.rename:
        action.rename_file(args.rename[0], args.rename[1])
    
    if args.netvar:
        if args.netvar[0] is None:
            action.netvar()
        else:
            action.netvar(args.netvar[0])

    if args.stop or args.stopforce:
        action.stop(force=args.stopforce)

    if args.start:
        action.start()

    if args.reboot:
        action.reboot()
    
    # if args.reset:
    #     action.reset()
    
    if args.status:
        action.print_status_info()


__pdoc__[&#39;main&#39;] = False


def command_line(*args):
    try:
        main(*args)
    except KeyboardInterrupt:
        print(&#39;Aborted.&#39;, end=&#39;\n\n&#39;)


__pdoc__[&#39;command_line&#39;] = False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<img src="kyanit_ctl_logo.svg">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#kyanit-ctl">Kyanit CTL</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#license-notice">License Notice</a></li>
</ul>
</div>
<ul id="index">
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>